== ポインタ

ポインタとは，メモリ上のあるアドレスを「指し示す（ポイント）」ための仕組みである．指し示すアドレスは有効なアドレスでなければならないので，必然的に既に宣言された変数(配列)の存在が前提となる．ポインタもまた変数であるので，ポインタ変数などとも呼ばれる．ここではポインタの基本について学習する．

=== 宣言方法
ポインタの宣言にはアスタリスク``pass:[*]``を用いて，

[source,c]
----
int *a;
double *x;
----

のように宣言する．変数の直前の``pass:[*]``がその変数がポインタであることを意味する．このようにして宣言されたポインタは，メモリ上のどこも指していないため，使用することができない．

CAUTION: 使用すると，おそらく実行時エラー(例えば``Segmentation fault``など)となる．

以下のようにポインタが指し示すアドレスを代入することで，初めて使用可能になる．

[source,c]
----
int *a;		// int型の変数を指し示すためのポインタ
int b = 10;	// int型の通常の変数
a = &b;		// ポインタaはbのアドレス(&はアドレスを求める演算子)を指す
----

もちろん，宣言と代入を同時に行うことも可能である．

[source,c]
----
int b = 10;
int *a = &b;
----


指し示すメモリが配列の場合は，以下のように書く．

[source,c]
----
char *c;
char name[20];
c = &name[0]; // または c = name;
----


以上の例のように，ポインタは，その宣言時にはアスタリスクを``pass:[*]``伴うものの，アドレスの代入時には``pass:[*]``が付かない．

=== 使用方法
指し示すアドレスが代入されたポインタは，以下のように使用できる．

[#nonarray]
==== 指し示すアドレスの中身(データ)へのアクセス: 配列でない場合

ポインタが指し示すアドレスの中身，すなわちデータを取得するには，以下のように書く．

[source,c]
----
 int a = 10;
 int *b = &a; // bは変数aのアドレスを指し示す
 printf("Data is d\n", *b); // bが指し示すアドレスの中身を取得

実行結果:
 Data is 10
----

また，ポインタが指し示すアドレスの中身を書き換えるには，

[source,c]
----
 int a = 10;
 int *b = &a; // bは変数aのアドレスを指し示す
 *b += 100; // bが指し示すアドレスの中身に100を足す
 printf("Data is d\n", *b); // bが指し示すアドレスの中身を取得

実行結果:
 Data is 110
----

以上のように，一度宣言されたポインタ変数の中身はアスタリスク``pass:[*]``で取得する．

[NOTE]
====
初学者にとってポインタがわかりにくいと言われる理由の一つが，このように同じアスタリスク記号を違う目的で使う文法にあると言われる．
====

==== 指し示すアドレスの中身(データ)へのアクセス: 配列の場合
配列を指し示すポインタの場合，さらに以下のような使い方ができる．

[#src:05_array00]
.ポインタを用いた配列の各要素へのアクセス
====
[source,c,linenums]
----
include::../examples/05_pointer_array00.c[]
----
====

このリストの実行結果は，

[listing]
----
 data[2] = 2
 data[2] = 10
----

となる．あたかも``p_data``という配列があるように見えるが，``p_data``はあくまでポインタである．配列を指し示すポインタはこのように指し示す配列の要素を大かっこを用いた添字で参照できる．このとき，<<nonarray>>で用いたようなアスタリスクは不要である．

==== 配列とポインタのパターン
配列へのポインタの典型的な使い方として，配列の初期化や，コピーがある．

===== ポインタを用いた配列の初期化

[#fig:05_pointer_move]
.ポインタによる配列へのアクセス例(初期化)
[align="center"]
image::05_pointer_move.png[]

[#src:05_array01]
.ポインタを用いた配列の初期化
====
[source,c,linenums]
----
include::../examples/05_pointer_array01.c[]
----
====


ここで，<<src:05_array01>>の6行目が必要な理由を考えよう．``for``文の中にある，``pass:[*p++ = 0]``の意味は，「``p``の指し示すアドレスの中身をゼロにして，その後，pが指し示すアドレスそのものをインクリメントせよ」である．

NOTE: ポインタの中身を取り出す``pass:[*]``は，インクリメント演算子よりも優先順位が低い．したがって，``pass:[*++p]``はポインタをインクリメントしてから値を参照することになり，``pass:[*p++]`` は値を参照してからポインタをインクリメントすることになる．

したがって，<<fig:05_pointer_move>>に示すように，ループの終わりには，``p``の指すアドレスは配列``data``の最後の要素のアドレスとなっている．すなわち，ループ終了後には，``p``は，配列``data``の範囲外のアドレスを指し示すことになる．ここで，仮に配列の先頭の要素``data[0]``に対してポインタ``p``を使ってアクセスしようとして，``p[0]``を用いようとすると，これは配列の範囲外のアドレスのため実行時エラーの原因となる．これを回避するために，配列``data[]``の先頭アドレスを別のポインタ``p_data``に保存しておき，後に利用するときには，再び``p = p_data``とする．<<fig:05_pointer_move>>からも，``p_data``は動いていないことが分かる．

===== ポインタを用いた配列のコピー

[#src:05_pointer_move]
.ポインタを用いた配列のコピー
====
[source,c,linenums]
----
include::../examples/05_pointer_array02.c[]
----
====

NOTE: 11-13行目はまとめて``pass:[*dp++ = *sp++;]``と書くことが可能．

[#fig:05_pointer_copy]
.ポインタによる配列へのアクセス例(コピー)
[align="center"]
image::05_pointer_copy.png[]

==== 関数の引数としてのポインタ
例として，2つの``int``型変数の値を入れ替える関数``swap``を考える．

===== これまでの関数における引数(値渡し)
C言語では，関数の引数として与えられた値は，そのコピーが関数の内部に渡される値渡しという方法であった．


[#src:05_swap1]
.2つの変数の値を交換しようとしたコード
====
[source,c,linenums]
----
include::../examples/05_pointer_swap.c[]
----
====


このコードの実行結果は，

[listing]
----
before: a = 1, b = 2
swap  : a = 2, b = 1
after : a = 1, b = 2
----

となる．明らかに，値の入れ替えに失敗していることがわかる．この理由は，関数``swap``には値渡し，すなわち引数のコピーが渡されるからである．したがって，入れ替えが行われるのはコピーされた変数に対してであり，呼び出し元の変数は影響を受けない．

関数``swap``内の``printf``文では，1と2が入れ替わって表示されているのはそのためである．入れ替えられたコピーは，``swap``関数の終わりで破棄されるので，呼び出し元の``main``関数での変数の値は変化していないことが分かる．

このように，これまでの引数の使い方(値渡し)は，関数の処理の局所性を向上させるには有効な方法であるが，入力される引数そのものを書き換える必要がある処理には使えないことが分かる．

===== 引数としてポインタを使った関数(参照渡し)
変数の値を入れ替えるために，関数の引数としてポインタを使用するコードの例を以下に示す．


[#src:05_swap2]
.2つの変数の値を交換するコード
====
[source,c,linenums]
----
include::../examples/05_pointer_swap2.c[]
----
====

このコードの実行結果は，

[listing]
----
before: a = 1, b = 2
swap  : a = 2, b = 1
after : a = 2, b = 1
----

となる．変数の入れ替えに成功していることが分かる．

<<src:05_swap1>>との違いは，関数``swap``の引数が``int``型のポインタになっていることである．関数の引数としてポインタを使うということは，(( *アドレス* ))を受け渡しするということである．値渡しが，呼び出し元で与えられた引数の値のコピーを受け渡しするのに対して，ポインタを使った(( *変数のアドレス* ))の受け渡し方法を(( *参照渡し* ))と言う．

したがって，<<src:05_swap2>>の``swap``関数で受け取るのは，呼び出し元の``main``関数で宣言された変数``a``および``b``の(( *アドレス* ))である．15行目のように，関数における仮引数名を``pass:[*a]``および``pass:[*b]``というように，アスタリスクを付けることによってこれらの仮引数がポインタであることを宣言している．17-20行目のように，ポインタとして宣言された仮引数名は，関数内でポインタとして振る舞うので，その中身にアクセス(値を読み取る，値を代入する)するには``pass:[*]``を付けている．

===== 参照渡しの応用
[sidebar]
.配列の参照渡し
--
配列を引数にする場合，ポインタを引数とし，その先頭アドレスを参照渡しすることが多い．


[#src:05_pointer_array_args]
.参照渡しによる配列へのアクセス
====
[source,c,linenums]
----
include::../examples/05_pointer_array_args.c[]
----
====

<<src:05_pointer_array_args>>の実行結果は，

[listing]
----
平均値は3.600000です
----

となる．

配列をポインタで受け渡しするときの注意は，配列の範囲外のアドレスにアクセスしないようにすることである．ここでは，配列の要素数を保持する変数``N``を宣言し，それを``get_average``関数に渡すことによって，範囲外アクセスを回避している．また，16行目の``(double)``は(( *キャスト* ))と呼ばれる，変数の型変換のための演算子である．このキャスト演算子によって，``int``型の``in[i]``は，``double``型に変換され，``sum``へと加算される．
--

[sidebar]
.複数の戻り値の代用としての参照渡し
--
C言語の戻り値の数の最大値は1である．ポインタを使った参照渡しを使って，2つ以上の戻り値と等価な動作を行う関数を作ることができる．以下の<<src:05_pointer_array_avgstd>>に，配列の要素の平均と標準偏差を求め，その結果をポインタを介して呼び出し元へ返す関数の例を示す．<<src:05_pointer_array_args>>と比較してみてほしい．このような関数の場合，本来の意味の戻り値としては0個で良いため，戻り値の方は``void``としている．``get_average_stdev``関数の最後の2つの引数は``double``型のポインタである．呼び出し元から与えるのは，``get_average_stdev``関数で求めた平均と標準偏差という2つの結果を格納すべきアドレスである．関数内で，求めた平均および標準偏差の値を代入・読み取りするときに，アスタリスクを付けてそれぞれのアドレスの中身にアクセスしていることが分かる．



[#src:05_pointer_array_avgstd]
.平均と分散を求めてポインタを介して結果を返す関数
====
[source,c,linenums]
----
include::../examples/05_pointer_array_avgstd.c[]
----
====


参考までに，<<src:05_pointer_array_avgstd>>の実行結果は，

[listing]
----
平均値は3.600000, 分散は2.416609です
----

となる．

ちなみに，標準偏差 latexmath:[S]は，平均をlatexmath:[\mu]として
[latexmath]
++++
S = \sqrt{\frac{1}{N}\sum_{i=0}^{N-1}|x_i - \mu|^2}
++++
[latexmath]
++++
\mu = \frac{1}{N}\sum_{i=0}^{N-1}x_i
++++
で定義される．
--