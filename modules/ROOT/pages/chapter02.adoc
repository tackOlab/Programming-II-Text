= 文字と文字列
ここでは，C言語における文字と文字列の取り扱いを学ぶ．文字型変数，配列，ファイル入出力が新たなトピックである．

== 文字
C言語における文字とは，文字型変数に格納可能なデータを意味する．文字型変数の型名は``char``である．``char``型は，1バイトのサイズを持ち，格納できる値は-128〜127までの整数である．<<tab:02_DataTypes>>にC言語で利用可能な変数の型の一部を示す．

[#tab:02_DataTypes]
.C言語で使用出来るデータ型(の一部，Windows 64bit)
[cols="^.^;^.^;^.^;^.^", options="header"]
[%autowidth]
|===
|種類| 型名 | サイズ(Byte) | 値の範囲 
^|文字型 | ``char``
>| 1
>| -2^7^ 〜 2^7^-1 
.3+^.^|整数型| ``short``
>| 2
>| -2^15 〜 2^15-1 
| ``int``
>| 4
>| -2^31 〜 2^31-1 
| ``longlong``
>| 8
>| -2^63 〜 2^63-1
.3+^.^|浮動小数点型| ``float``
>| 4
>| 1.175494×10^-38^ 〜 3.402823× 10^38^
| ``double``
>| 8
>| 2.225074×10^-308^ 〜 1.797693×10^308^
|``long`` ``double``
>| 16
>| 3.362103×10^-4932^ 〜 1.189731×10^4932^
|===

文字型に格納可能な値と，ファイルに記録あるいは画面に表示される文字との対応関係を定めたものがASCIIコードである．<<tab:02_ASCII>>にASCIIコードを示す．0番から31番までは制御コードであり，画面に表示されないことに注意．

[#tab:02_ASCII]
.ASCIIコード表
[cols=">.^;^.^;>.^;^.^;>.^;^.^;>.^;^.^;>.^;^.^;>.^;^.^;>.^;^.^;>.^;^.^"]
[%autowidth]
|===
|0|``NUL``|1|``SOH``|2|``STX``|3|``ETX``|4|``EOT``|5|``ENQ``|6|``ACK``|7|``BEL``
|8|``BS``|9|``HT``|10|``NL``|11|``VT``|12|``NP``|13|``CR``|14|``SO``|15|``SI``
|16|``DLE``|17|``DC1``|18|``DC2``|19|``DC3``|20|``DC4``|21|``NAK``|22|``SYN``|23|``ETB``
|24|``CAN``|25|``EM``|26|``SUB``|27|``ESC``|28|``FS``|29|``GS``|30|``RS``|31|``US``
|32|``SP``|33|``!``|34|``"``|35|``#``|36|``$``|37|``%``|38|``&``|39|``'``
|40|``(``|41|``)``|42|``*``|43|``+``|44|``,``|45|``-``|46|``.``|47|``/``
|48|``0``|49|``1``|50|``2``|51|``3``|52|``4``|53|``5``|54|``6``|55|``7``
|56|``8``|57|``9``|58|``:``|59|``;``|60|``<``|61|``=``|62|``>``|63|``?``
|64|``@``|65|``A``|66|``B``|67|``C``|68|``D``|69|``E``|70|``F``|71|``G``
|72|``H``|73|``I``|74|``J``|75|``K``|76|``L``|77|``M``|78|``N``|79|``O``
|80|``P``|81|``Q``|82|``R``|83|``S``|84|``T``|85|``U``|86|``V``|87|``W``
|88|``X``|89|``Y``|90|``Z``|91|``[``|92|``\``|93|``]``|94|``^``|95|``_``
|96|`` ` ``|97|``a``|98|``b``|99|``c``|100|``d``|101|``e``|102|``f``|103|``g``
|104|``h``|105|``i``|106|``j``|107|``k``|108|``l``|109|``m``|110|``n``|111|``o``
|112|``p``|113|``q``|114|``r``|115|``s``|116|``t``|117|``u``|118|``v``|119|``w``
|120|``x``|121|``y``|122|``z``|123|``{``|124|``\|``|125|``}``|126|``~``|127|``del``
|===

文字型変数に値を代入し，``printf`` 関数によって表示するサンプルソースコードを<<src:02_charexample>>に，また，その実行結果を<<src:02_aout_char_example>>に示す．``printf``関数での書式指定によって，変数の中身を文字として表示するか，数値として表示するかを制御できることが分かる．

[#src:02_charexample]
.char型変数への代入
====
[source,c,linenums]
----
include::example$/char_example.c[]
----
====

[#src:02_aout_char_example]
[source]
.char型変数への代入の実行結果
====
A A +
65 65
====

== 文字列
文字列とは文字の集合体である．では，``char`` 型の値（すなわち，文字）の集合体はどのように定義するのだろうか．C言語では同じ型の値の集合体を定義するための，*配列（array）* と呼ばれるデータ構造が用意されている．以下では，文字列を定義するための配列の利用方法について解説する．
  
[NOTE]
====
配列についての一般的な内容は次回で学習する．
====

文字列を定義するためには，文字型変数の配列を宣言する．配列の宣言には，配列の要素数を予め決定し，明示する必要がある．例えば，10文字からなる文字列``name``を宣言するには，
  
[source,c]
char name[10];
  
と記述する．この宣言によって<<fig:02_array>>のように，``char``型の値を10個格納するため領域が，メモリ上に確保される．

[#fig:02_array]
.10文字からなる文字列name
[align="center"]
image::02_fig_array.png[{half-width}]


配列の各要素には0から始まる添字と，大かっこを用いて``name[3]``のようにアクセスできる．添字には定数以外にも，整数式を用いることができる．例えば

[source,c]
----
int i = 1;
char a[30];
a[2*i+1] = 'A';
----

などと記述することができる．なお，宣言直後の配列の中身はランダムな値が入っているため，初期化することが望ましい．配列の初期化の典型的なパターンを<<src:02_init_array>>に示す．

[#src:02_init_array]
.配列の初期化
====
[source,c,linenums]
----
include::example$/init_array.c[]
----
====

//\lstinputlisting[caption=配列の初期化,label=src:02_init_array]{\PATHtoSRC init_array.c}

<<fig:02_array>>の配列に，Takushokuという単語をキーボードから入力するには
[source,c]
----
scanf("%s", &name[0]);
----

と記述する．``scanf``の第2引数には，キーボードからの入力を格納する変数のアドレスを与えるが，ここでは``name``という配列の先頭の要素を指すアドレスを与えていることがわかる．配列の先頭アドレスの省略形として配列名を使うこともできる．

[NOTE]
====
次回で学習する多次元配列ではこの限りではないので注意．
====

すなわち，省略形を使う場合には，
[source,c]
scanf("%s", name);

と記述する．

キーボードからTakushokuと入力した直後のメモリの中身は<<fig:02_array_filled>>のようになっている．

[#fig:02_array_filled]
.Takushokuと入力後の文字列nameの中身
[align="center"]
image::02_fig_array_filled.png[scaledwidth=50%,role=half-view-width]

最後の要素にキーボードからの入力ではない``\0``が挿入されていることがわかる．この``\0``は文字列の区切りを表すためのシンボルであり，null記号と呼ばれる．したがって，配列の宣言時には，想定される文字数の最大値+1を配列の要素数とする必要がある．``\0``の役割は，要素数よりも短い文字数の単語が入力された場合に，その単語の終わりを示すことである．

== ファイル入出力
プログラム内でデータファイルを読み書き，すなわち入出力を行うためには，ファイルのオープンおよびクローズ処理が必要となる．

=== ファイルのオープン
ファイルをオープンするためには，``fopen``関数を用いる．基本的な使用方法は以下のとおりである．

[source,c]
----
FILE *fp; // ファイルポインタ
fp = fopen("ファイルのパス\ファイル名", モード);
----

ファイルポインタ:: オープン後のファイルからデータを読み込んだり，あるいはファイルにデータを書き込む際に，ファイル名の代わりに使う識別子のようなもの．

モード:: オープンしたファイルからデータを読み込むときには``"r"``，ファイルにデータを上書きするときには``"w"``，追記するときには``"a"``を用いる．また，データの格納形式はバイナリ形式の際には``"rb", "wb"``のように``b``を追加する．

=== ファイルのクローズ
ファイルをクローズするには``fclose``関数を用いる．使用方法は以下の通りである．

[source,c]
fclose(クローズするファイルのファイルポインタ);

=== ファイルから1文字を読み込む
オープンしたファイルから1文字を読み込むには``getc``関数を用いる．使用例を<<src:02_getc>>に示す．

[#src:02_getc]
.getc関数の使い方
====
[source,c,linenums]
----
include::example$/getc.c[]
----
====

ここで，6行目の``c != EOF``について解説する．``EOF``はEnd of Fileの略であり，ファイルの終端を示す特別な値である．``EOF``の値は，コンパイラによって異なってもよいことになっており，``char`` 型の範囲外の値も取りうるため，``getc``関数は``int`` 型の値を返す仕様となっている．

[NOTE]
====
本講義で用いるコンパイラではEOFの値は-1を取る
====

== 文字検査関数
ファイルから読み込んだ文字の種類を判別する必要が生じることがある．たとえば，その文字が数字なのか，アルファベットなのか，アルファベットなら大文字なのか，小文字なのか，といった具合である．この判別を可能とするのが文字検査関数である．文字検査関数を使用するには``ctype.h``をインクルードする必要がある．

<<src:02_example_isdigit>>に，文字が10進数の数字かどうかを判別する``isdigit()``関数の使用例
を示す．

[#src:02_example_isdigit]
.isdigit関数の使用例
====
[source,c,linenums]
----
include::example$/example_isdigit.c[]
----
====

すべての文字検査関数はその引数に``int``型を取る．``isdigit``関数においては，引数の文字が10進数の数字であったときに，非ゼロの値が，10進数の数字ではなかったときにゼロが戻り値となる．以下に，文字検査関数の一覧を示す．

[horizontal]
 ``isalnum ``:: 文字がアルファベットもしくは数字かどうか
 ``isalpha ``:: 文字がアルファベットかどうか
 ``isblank ``:: 文字が標準ブランク文字かどうか
 ``iscntr ``:: 文字が制御文字 (control character) かどうか
 ``isdigit ``:: 文字が10進数の数字かどうか
 ``isgraph ``:: 文字が空白 (' ') を除く表示文字 (printing character) かどうか
 ``islower ``:: 文字がアルファベットの小文字かどうか
 ``isprint ``:: 文字が表示文字かどうか 
 ``ispunct ``:: 文字が区切り文字 (punctuation character) かどうか
 ``isspace ``:: 文字が標準空白類文字かどうか
 ``isupper ``:: 文字がアルファベットの大文字かどうか
 ``isxdigit``:: 文字が16進数の数字かどうか 


== 文字列処理関数
``string.h``をインクルードすることで文字列を操作するための標準関数
が使えるようになる．そのうち，よく用いられる関数について以下で説明する．

[.big]#``strcmp``#:: 文字列の比較を行う．2つの文字列があり，その先頭アドレスを``s1``と``s2``とするとき，

[source,c]
----
if (strcmp(s1, s2) == 0) {
	:
----

のように用いる．この関数は``s1の中身のASCIIコード < s2の中身のASCIIコード``ならば負の値，``s1の中身のASCIIコード == s2の中身のASCIIコード``ならばゼロ，は``s1の中身のASCIIコード > s2の先中身のASCIIコード``ならば正の値を返す．これを用いて例えばアルファベット順での順位の比較などを行うことができる．

[.big]#``strcpy``#:: 文字列のコピーを行う．コピー元の文字列の先頭アドレスを``src``，コピー先の文字列の先頭アドレスを``dst``とするとき，

[source,c]
----
strcpy(dst, src)
----

のように用いる．終端記号``\0``までコピーされる．コピー先のアドレスで示される領域とコピー元の領域に重なりがある場合，この関数の動作は未定義であるため，使用には注意を要する．

この他にも``memcpy``, ``memmove``, ``memset``などよく使われる関数があるが，ここでは説明を割愛する．