== 関数とマクロ

プログラム開発において，ある処理のまとまりが複数回必要になることがある．C言語では，このような処理のまとまりを関数として記述することができる．処理を関数にすることによって，同じようなコードをいくつも記述する必要がなくなるため開発の効率が向上する．また，同じ処理はひとつの関数に集約されるため，デバッグ作業の効率も向上する．また，比較的小規模な処理は，マクロとして記述することも可能である． ここではC言語における関数とマクロの基本について学習する．

=== 標準ライブラリ関数
これまでに使用してきた``printf``などの関数は，標準ライブラリ関数と呼ばれる．C言語では，``main``関数を除く全ての関数は，その呼び出しよりも前に定義されるか，プロトタイプ宣言がなされる必要がある．しかし，例えば``printf``を定義したり，そのプロトタイプ宣言を明示的に書いた記憶はおそらくないはずである．標準ライブラリ関数を使用するためには，``main``関数よりも前に，``#include``を用いて，関数の定義が書かれたヘッダーファイルを読み込む必要がある．これまでに特に説明もなくプログラムの先頭に``#include <stdio.h>``と書いていたのはこのためである．以下に主な標準ライブラリ関数のためのヘッダーファイルを示す．

[horizontal]
 ``stdio.h``::  標準入出力．``printf``や``scanf``，ファイル入出力関数など
 ``stdlib.h``:: ユーティリティ．``exit``関数や``EXIT_SUCCESS``などのマクロ定義も含まれる．
 ``math.h``:: 数学．三角関数や絶対値，指数関数や対数関数など．
 ``ctype.h``:: 文字列検査関数．``isalpha``など．
 ``string.h``:: 文字列操作関数．文字列の連結やコピー，ソートのための大小比較など．
 ``limits.h``:: 整数型に関する最大値や最小値などのマクロ定義．
 ``float.h``:: 浮動小数点型に関する最大値や最小値などのマクロ定義．
 ``time.h``:: 日付および時間．現在時刻の取得や，プログラムの実行時間計測のための関数．


``#include <*.h>``と書くことを，そのヘッダーファイルをインクルードするという．例えば数学関数を使用するには``math.h``をインクルードする必要がある．``< >``は，あらかじめシステムに定義されたパスに目的のヘッダーファイルが存在することを意味する．

[NOTE]
====
自前のヘッダーファイルをインクルードするときなど，任意のパスに置かれたヘッダーファイルをインクルードするときには``" "``を用いる．
====

=== ユーザ関数
==== 定義および使用方法
自分で関数を定義するには，

* 名前
* 戻り値とそのデータ型
* 引数の個数と，それぞれのデータ型

を決定する必要がある．C言語では，戻り値は最大で1つまでという制約がある．戻り値なし(すなわち0個)の場合には，その型は``void``型とする．引数の個数には制約は存在しない．

[NOTE]
====
極端に多い引数は，エラーの原因となることがある
====

関数宣言のフォーマットを図<<fig:04_funcdef>>に示す．この図において，引数のリストが，単に「引数」ではなく，なぜ「仮引数」であるのかについては後述する．

[#fig:04_funcdef]
.2関数宣言のフォーマット
[align="center"]
image::04_funcdef.png[{half-width}]

例として，2つの整数値を引数として受け取り，その合計を戻り値として返す関数``add``を考えよう．関数の名前は``add``，戻り値の型は``int``，引数の個数は``int``型2つである．リスト<<src:04_add>>に，この関数の定義，および使用例を示す．

[#src:04_add]
.関数の定義例
====
[source,c,linenums]
----
include::../sources/04_add.c[]
----
====

3行目では，関数のプロトタイプ宣言を行っている．プロトタイプ宣言は，関数の定義(実体ともいう)が，``main``関数よりも後に来る場合には必ず必要になる．

定義された関数を実行することを関数呼び出しという．``main``関数内において，``add``関数は，8行目と10行目の2回，呼び出されている．8行目では，``add``関数によって``a``と``b``の値が加算された結果が17行目の``return``文によって戻り値として返され，``c``に代入されている．10行目では，2+3の結果，つまり5が戻り値として返ってきている．つまり，``add``関数を呼び出す側からみると，``add()``は，その関数の戻り値とみなすことができる．

==== 仮引数による値渡し
先に述べたように，リスト<<src:04_add>>内の``add``関数の定義における``x``，``y``は，(( *仮引数* ))と呼ばれる．これに対して，``a``，``b``，2や3は，``add``関数を呼び出す際に与える引数であり，(( *実引数* ))と呼ばれる．C言語では，関数呼び出し時に，実引数のコピーが自動的に作られ，そのコピーに名前を付けたものが仮引数となる．これを(( *値渡し* ))による関数呼び出しという．実引数には，変数以外にも，式や定数が使えるが，仮引数はその性質上，変数名のみが許されている．

[NOTE]
====
値渡しではない呼び出し方法として(( *参照渡し* ))があるが，これについてはポインタの回で説明する．
====

関数の定義内で参照できる仮引数は，あくまで実引数のコピーであるため，仮引数の値を関数内で変更したとしても，呼び出し側の実引数の値は変わらない．以下のコードを用いてこの関係を確認できる．

[#src:04_no_change_args]
.実引数と仮引数の関係
====
[source,c,linenums]
----
include::../sources/04_no_change_args.c[]
----
====

リスト<<src:04_no_change_args>>の実行結果は以下のとおりである．呼び出し側の変数``a``と``b``の値は変わっていないことが分かる．

[listing]
----
5+2と10+2の和は19です
----

=== マクロ
マクロとは，本来，マクロ名で示される文字列を，他の文字列で置き換える機能を指す．C言語では，コンパイラが動作する前に，プリプロセッサと呼ばれるプログラムが動作する．マクロ機能は，プリプロセッサが持つ機能の一つであり，コンパイラは文字列が置換されたソースコードをコンパイルする．

==== 単純なマクロ
単純な文字列置き換えのためのマクロの定義の方法は

[source,c]
----
#define	記号定数	文字列
----

である．
ソースコード中の文字列``PI``を円周率として用いるためのマクロの定義
例は以下の通りである．
[source,c]
----
#define	PI 3.141592653589793
----

これ以降のソースコード中の文字列``PI``は，文字列``3.141592653589793``に置き換えられるので，あたかも``PI``という変数が円周率という定数を参照するために定義されているように用いることができる．

==== 引数付きマクロ

仮引数を含むマクロ定義によって，比較的短い処理を関数定義を行うことなく記述することができる．

[source,c]
----
#define マクロ名 (仮引数の並び)
----

例えば，角度(°)をラジアンに変換する処理は以下のように書ける．

[source,c]
----
#define	rad(x) ((x) * PI / 180)
----

マクロ名と仮引数の並びの間にスペースを入れてはいけない．スペースが入るとこの場合，``rad``という文字列が``(x)``という文字列に置換されるマクロになってしまう．また，仮引数が()で囲まれていることに注意．この括弧がない場合，思わぬ副作用が生じる可能性がある．例えば2つの整数を乗算するマクロとして，

[source,c]
----
#define	multiply(a, b) (a * b)
----

というマクロを定義したとする．$3\times 7$の計算結果を期待して

[source,c]
----
multiply(1 + 2, 3 + 4)
----

と使用すると，実際には``a -> 1 + 2``，``b -> 3 + 4``であるので

[source,c]
----
1 + 2 * 3 + 4
----

という意図しない計算が行われることになる．括弧をつけた定義

[source,c]
----
#define	multiply(a, b) ((a) * (b))
----

であれば，

[source,c]
----
(1 + 2) * (3 + 4)
----

と，意図する計算が実行される．

引数付きマクロでは(( *3項演算子* ))もよく用いられる．3項演算子は，条件によって代入される値を変えるための演算子であり，しばしば``if``文の代わりに使われる．3項演算の文法は以下の通りである．

[source,c]
----
条件 ? 真のときの値 : 偽のときの値
----

2つの整数のうち，大きい方を求めるマクロは，3項演算子を用いて以下のように書ける．

[source,c]
----
#define	MAX(a, b) (((a)>(b)) ? (a) : (b))
----
